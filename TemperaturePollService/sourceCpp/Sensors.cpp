
#include <thread>
#include "Sensors.h"


// initialized storage for static data-members

duration<int,ratio<1,1>> Sensors::sleep_time { TIMER_REPEAT_TIME };

string Sensors::rawDataString {};
vector<struct PhysicalSensorsData> Sensors::sensorData {};
struct WriteMemoryStruct Sensors::content {};
struct curl_slist *Sensors::poll_headers {};
CURLM *Sensors::poll_handle {};
CURLM *Sensors::sendfile_handle {};
Parser *Sensors::parser {};
struct tm Sensors::oldTime {};
struct tm Sensors::actTime {};
string Sensors::fileName {};
string Sensors::remoteFileName {};
FILE *Sensors::fileToSend {};

// private functions

size_t Sensors::write_data( void *buffer, size_t size, size_t nmemb, void *userp )
{
  // function "write_data" may be called more than once
  // "buffer": pointer to new data to be saved
  // "size": always equal 1
  // "nmemb": size of data to be saved, maybe equal 0
  // return value: size of processed data, 
  //    if unequal to nmemb -> CURLE_WRITE_ERROR will be generated by curl

  struct WriteMemoryStruct *mem = (struct WriteMemoryStruct *)userp;

  vector<char> buff( (char *)buffer, (char *)buffer + nmemb );
  mem->memory.insert( mem->memory.end(), buff.begin(), buff.end() );
  mem->size += nmemb;

  return nmemb;
}


void Sensors::construct_poll_handle()
{
    poll_handle = curl_easy_init();
    if( poll_handle == NULL ) throw;

    // set parameters for reading from URL
    poll_headers = NULL;

    curl_easy_setopt( poll_handle, CURLOPT_URL, URL );
    curl_easy_setopt( poll_handle, CURLOPT_HTTPGET, 1L );
    curl_easy_setopt( poll_handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1 );
    curl_easy_setopt( poll_handle, CURLOPT_WRITEFUNCTION, write_data );
    curl_easy_setopt( poll_handle, CURLOPT_WRITEDATA, (void *)&content );

    // pass our list of custom made headers
    curl_easy_setopt( poll_handle, CURLOPT_HTTPHEADER, poll_headers );
}


void Sensors::destruct_poll_handle()
{
    curl_slist_free_all( poll_headers );
    curl_easy_cleanup( poll_handle );
}


void Sensors::getRawDataString()
{
    content.memory = {};              // no data initially
    content.memory.reserve( 3000 );   // approximated max. size
    content.size = 0;

    CURLcode cres = curl_easy_perform( poll_handle );
    if( cres != CURLE_OK ) throw;

    rawDataString = string( content.memory.begin(), content.memory.end() );
}


void Sensors::setTime( struct tm *buffer )
{
  time_t t = time( NULL );
  localtime_r( &t, buffer );
}


string Sensors::time2string( struct tm usedTM )
{
#define NALLOC 25   // maximal needed buffer size should be 20: "%02d.%02d.%04d %02d:%02d:%02d"

  char * cbuff = (char *)malloc( NALLOC );

  int ret = snprintf( cbuff, NALLOC, "%02d.%02d.%04d %02d:%02d:%02d",
    usedTM.tm_mday, usedTM.tm_mon + 1, usedTM.tm_year + 1900,
    usedTM.tm_hour, usedTM.tm_min, usedTM.tm_sec );

  string time( cbuff, 0, ret );

  free( cbuff );

  return time;
}


void Sensors::parseSensorsData()
{
    // parse rawdata string containing all sensors and
    // separate individual rawdata strings for each sensor
    auto rawData = parser->getSensorsRawDataStrings( rawDataString );
    int virtualSensorsCount = rawData.size();

    // parse individual rawdata string for each sensor for getting
    // sensors name, config- and state-strings and wether it is interesting
    for( auto & iter: rawData )
    {
      iter.name = parser->getSensorName( string( iter.allData ) );
      iter.config = parser->getSensorConfig( string( iter.allData ) );
      iter.state = parser->getSensorState( string( iter.allData ) );
      iter.interesting = parser->isInterestingSensor( string( iter.config ) );
    }

    // count interesting sensors (those with a battery!)
    int sensorsOfInterestCount = 0;
    for( auto & iter: rawData )
      if( iter.interesting )
        ++sensorsOfInterestCount;

    // every interesting sensor must consist of 3 "physical" sensors
    // for temperature, pressure and humidity
    if( sensorsOfInterestCount % 3 != 0 ) throw;

    int physSensorsCount = sensorsOfInterestCount / 3;

    // determine the sensors names (they must be unique)
    int sensorsNamesCount = 0;
    auto sensorNames = parser->sensorsNames( virtualSensorsCount, rawData, &sensorsNamesCount );

    // plausibility-check
    if( sensorsNamesCount != physSensorsCount ) throw;

    sensorData = parser->getMeasurementData( physSensorsCount, virtualSensorsCount, 
      sensorNames, rawData, time2string( actTime ) );
}


void Sensors::manageTime()  // get actual timestamp and provide actual filename for file transfer to NAS
{
  oldTime = actTime;
  setTime( &actTime );

  // change of calender day -> create new filenames
  if( oldTime.tm_mday != actTime.tm_mday ) generateFileNames();
}


void Sensors::generateFileNames()
{
    // generate new filename, deconstruct old curl-handle, construct new curl-handle
    fileName = string( FILENAME_PREFIX );
    string datetime = time2string( actTime );
    size_t ndx = datetime.find_first_of( ' ' );
    fileName += string(  datetime.begin(), datetime.begin() + ndx );
    fileName += string( FILENAME_POSTFIX );

    remoteFileName = string( DISKSTATION );
    remoteFileName += fileName;
}


void Sensors::construct_sendfile_handle()
{
    sendfile_handle = curl_easy_init();
    if( sendfile_handle == NULL ) throw;

    fileToSend = fopen( fileName.c_str(), "r" );
    if( fileToSend == NULL ) throw;

    // set parameters for filetransfer to NAS
    curl_easy_setopt( sendfile_handle, CURLOPT_URL, remoteFileName.c_str() );
    curl_easy_setopt( sendfile_handle, CURLOPT_READDATA, (void *)fileToSend );
    curl_easy_setopt( sendfile_handle, CURLOPT_UPLOAD, 1L );
    curl_easy_setopt( sendfile_handle, CURLOPT_FTP_CREATE_MISSING_DIRS, CURLFTP_CREATE_DIR );
    curl_easy_setopt( sendfile_handle, CURLOPT_USERPWD, FTPCREDENTIALS );
}


void Sensors::destruct_sendfile_handle()
{
    int ret = fclose( fileToSend );
    if( ret != 0 ) throw;

    curl_easy_cleanup( sendfile_handle );
}


void Sensors::transferDataFile()
{
  construct_sendfile_handle();

  CURLcode cres = curl_easy_perform( sendfile_handle );
  if( cres != CURLE_OK ) throw;

  destruct_sendfile_handle();
}


void Sensors::writeDataToFile()
{
  string at = time2string( actTime );

  FILE *file = fopen( fileName.c_str(), "a" );
  if( file == NULL ) throw;

  fprintf( file, "%s", at.c_str() );
  fprintf( file, ", " );

  string str;
  for( size_t i = 0; i < sensorData.size(); ++i )
  {
    str = sensorData[i].sensorname;
    fprintf( file, "%s", str.c_str() );
    fprintf( file, ", " );

    str = sensorData[i].batterycharge;
    fprintf( file, "%s", str.c_str() );
    fprintf( file, ", " );

    str = sensorData[i].humidity;
    fprintf( file, "%s", str.c_str() );
    fprintf( file, ", " );

    str = sensorData[i].pressure;
    fprintf( file, "%s", str.c_str() );
    fprintf( file, ", " );

    str = sensorData[i].temperature;
    fprintf( file, "%s", str.c_str() );
    fprintf( file, ", " );

    str = sensorData[i].sensordate;
    fprintf( file, "%s", str.c_str() );
    fprintf( file, ", " );

    str = sensorData[i].sensortime;
    fprintf( file, "%s", str.c_str() );

    if( i != sensorData.size() - 1 )
      fprintf( file, ", " );
  }

  fprintf( file, "\n" );

  int ret = fclose( file );
  if( ret != 0 ) throw;
}

// public functions

Sensors::Sensors()
{
  setTime( &actTime );    // initialize both time stamps
  oldTime = actTime;

  generateFileNames();    // initialize filenames

  // initialize static class data
  CURLcode ret = curl_global_init( CURL_GLOBAL_ALL ); // curl global init
  if( ret != CURLE_OK ) throw;

  construct_poll_handle();
  parser = new Parser();
}


Sensors::~Sensors()
{
  delete parser;
  destruct_poll_handle();

  curl_global_cleanup();  // curl global cleanup
}


void Sensors::executionloop()
{
#ifdef DEBUG
  int count = 0;
  while( count <= 3 )
  {
    ++count;
#else
  while( true )
  {
#endif
    manageTime();       // get actual timestamp and provide actual filename for file transfer to NAS
    getRawDataString(); // read Zigbee gateways REST-API to get the rawdata string containing all sensors
    parseSensorsData(); // parse this rawdata string
    writeDataToFile();  // write parsed sensor data into file
    transferDataFile(); // FTP-transfer this file to NAS

    this_thread::sleep_for( sleep_time ); // wait TIMER_REPEAT_TIME seconds
  }
}